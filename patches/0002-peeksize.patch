diff --git a/src/AsynDriverInterface.cc b/src/AsynDriverInterface.cc
index 0268ece..4cac564 100644
--- a/src/AsynDriverInterface.cc
+++ b/src/AsynDriverInterface.cc
@@ -261,8 +261,7 @@ AsynDriverInterface(Client* client) : StreamBusInterface(client)
     pasynGpib = NULL;
     eventMask = 0;
     receivedEvent = 0;
-    peeksize = 1;
-    debug ("AsynDriverInterface(%s) createAsynUser\n", client->name());
+    peeksize = getPeekSize();
     pasynUser = pasynManager->createAsynUser(handleRequest,
         handleTimeout);
     assert(pasynUser);
@@ -667,25 +666,28 @@ writeHandler()
 
     pasynUser->timeout = 0;
     if (!pasynGpib)
-    // discard any early input, but forward it to potential async records
-    // thus do not use pasynOctet->flush()
-    // unfortunately we cannot do this with GPIB because addressing a device as talker
-    // when it has nothing to say is an error. Also timeout=0 does not help here (would need
-    // a change in asynGPIB), thus use flush() for GPIB.
-    do {
-        char buffer [256];
-        size_t received = 0;
-        int eomReason = 0;
-        debug("AsynDriverInterface::writeHandler(%s): reading old input\n",
-            clientName());
-        status = pasynOctet->read(pvtOctet, pasynUser,
-            buffer, sizeof(buffer), &received, &eomReason);
-        if (status == asynError || received == 0) break;
+    {
+        // discard any early input, but forward it to potential async records
+        // thus do not use pasynOctet->flush()
+        // unfortunately we cannot do this with GPIB because addressing a device as talker
+        // when it has nothing to say is an error. Also timeout=0 does not help here (would need
+        // a change in asynGPIB), thus use flush() for GPIB.
+        do {
+            char buffer [256];
+            size_t received = 0;
+            int eomReason = 0;
+            debug("AsynDriverInterface::writeHandler(%s): reading old input\n",
+                clientName());
+            status = pasynOctet->read(pvtOctet, pasynUser,
+                buffer, sizeof(buffer), &received, &eomReason);
+            if (status == asynError || received == 0) break;
 #ifndef NO_TEMPORARY
-        if (received) debug("AsynDriverInterface::writeHandler(%s): flushing %ld bytes: \"%s\"\n",
-            clientName(), (long)received, StreamBuffer(buffer, received).expand()());
+            if (received) debug("AsynDriverInterface::writeHandler(%s): flushing %ld bytes: \"%s\"\n",
+                clientName(), (long)received, StreamBuffer(buffer, received).expand()());
 #endif
-    } while (status == asynSuccess);
+        } while (status != asynTimeout && status != asynError);
+        // MCB - If we don't check for asynError, we can be hung here, locked up forever!
+    }
     else
     {
         debug("AsynDriverInterface::writeHandler(%s): flushing old input\n",
@@ -910,7 +912,10 @@ readHandler()
         } while (deveoslen);
     }
 
-    long bytesToRead = peeksize;
+	peeksize = getPeekSize();
+	if( peeksize == 0 )
+        peeksize = inputBuffer.capacity();
+    size_t	bytesToRead = peeksize;
     long buffersize;
 
     if (expectedLength > 0)
@@ -939,12 +944,15 @@ readHandler()
     {
         pasynUser->timeout = replyTimeout;
     }
-    bool waitForReply = true;
-    size_t received;
-    int eomReason;
-    asynStatus status;
-    long readMore;
-    int connected;
+	debug(	"AsynDriverInterface::readHandler(%s): "
+			"bytesToRead=%zu buffersize=%lu peeksize=%d expectedLength=%ld\n",
+			clientName(), bytesToRead, buffersize, peeksize, expectedLength ); 
+    bool			waitForReply = true;
+    size_t			received;
+    int				eomReason;
+    asynStatus		status;
+    long			readMore;
+    int				connected;
 
     while (1)
     {
@@ -953,26 +961,31 @@ readHandler()
         eomReason = 0;
         
         debug("AsynDriverInterface::readHandler(%s): ioAction=%s "
-            "read(..., bytesToRead=%ld, ...) "
+            "read(..., bytesToRead=%zu, ...) "
             "[timeout=%g sec]\n",
             clientName(), ioActionStr[ioAction],
             bytesToRead, pasynUser->timeout);
-        status = pasynOctet->read(pvtOctet, pasynUser,
-            buffer, bytesToRead, &received, &eomReason);
-        debug("AsynDriverInterface::readHandler(%s): "
-            "read returned %s: ioAction=%s received=%ld, eomReason=%s, buffer=\"%s\"\n",
-            clientName(), asynStatusStr[status], ioActionStr[ioAction],
-            (long)received,eomReasonStr[eomReason&0x7],
-            StreamBuffer(buffer, received).expand()());
+        status = pasynOctet->read(	pvtOctet,	pasynUser,
+            						buffer,		bytesToRead,
+									&received,	&eomReason	);
+        if (ioAction == Read || status != asynTimeout)
+        {
+			debug("AsynDriverInterface::readHandler(%s): "
+				"read returned %s: ioAction=%s received=%zu, eomReason=%s, buffer=\"%s\"\n",
+				clientName(), asynStatusStr[status], ioActionStr[ioAction],
+				received,eomReasonStr[eomReason&0x7],
+				StreamBuffer(buffer, received).expand()());
+        }
 
         pasynManager->isConnected(pasynUser, &connected);
         debug("AsynDriverInterface::readHandler(%s): "
-            "device is now %sconnected\n",
-            clientName(),connected?"":"dis");        
+            "device is %s\n",
+            clientName(),connected?"connected":"disconnected");
         // asyn 4.16 sets reason to ASYN_EOM_END when device disconnects.
         // What about earlier versions?
-        if (!connected) eomReason |= ASYN_EOM_END;
-        
+        if (!connected)
+			eomReason |= ASYN_EOM_END;
+
         if (status == asynTimeout &&
             pasynUser->timeout == 0.0 &&
             received > 0)
@@ -990,9 +1003,9 @@ readHandler()
                 {
 #ifndef NO_TEMPORARY
                     debug("AsynDriverInterface::readHandler(%s): "
-                        "AsyncRead poll: received %ld of %ld bytes \"%s\" "
+                        "AsyncRead poll: received %zu of %zu bytes \"%s\" "
                         "eomReason=%s [data ignored]\n",
-                        clientName(), (long)received, bytesToRead,
+                        clientName(), received, bytesToRead,
                         StreamBuffer(buffer, received).expand()(),
                         eomReasonStr[eomReason&0x7]);
 #endif
@@ -1005,9 +1018,9 @@ readHandler()
                 }
 #ifndef NO_TEMPORARY
                 debug("AsynDriverInterface::readHandler(%s): "
-                        "received %ld of %ld bytes \"%s\" "
+                        "received %zu of %zu bytes \"%s\" "
                         "eomReason=%s\n",
-                    clientName(), (long)received, bytesToRead,
+                    clientName(), received, bytesToRead,
                     StreamBuffer(buffer, received).expand()(),
                     eomReasonStr[eomReason&0x7]);
 #endif
@@ -1068,9 +1081,9 @@ readHandler()
 #ifndef NO_TEMPORARY
                 debug("AsynDriverInterface::readHandler(%s): "
                         "ioAction=%s, timeout [%g sec] "
-                        "after %ld of %ld bytes \"%s\"\n",
+                        "after %zu of %zu bytes \"%s\"\n",
                     clientName(), ioActionStr[ioAction], pasynUser->timeout,
-                    (long)received, bytesToRead,
+                    received, bytesToRead,
                     StreamBuffer(buffer, received).expand()());
 #endif
                 if (ioAction == AsyncRead || ioAction == AsyncReadMore)
@@ -1131,7 +1144,7 @@ readHandler()
             bytesToRead = inputBuffer.capacity();
         }
         debug("AsynDriverInterface::readHandler(%s) "
-            "readMore=%ld bytesToRead=%ld\n",
+            "readMore=%ld bytesToRead=%zu\n",
             clientName(), readMore, bytesToRead);
         pasynUser->timeout = readTimeout;
         waitForReply = false;
diff --git a/src/StreamBuffer.h b/src/StreamBuffer.h
index e4cb6a6..b6ac6a5 100644
--- a/src/StreamBuffer.h
+++ b/src/StreamBuffer.h
@@ -74,7 +74,7 @@ public:
         {init(NULL, size);}
 
     ~StreamBuffer()
-        {if (buffer != local) delete buffer;}
+        {if (buffer != local) delete [] buffer;}
 
     // operator (): get char* pointing to index
     const char* operator()(ssize_t index=0) const
diff --git a/src/StreamBusInterface.h b/src/StreamBusInterface.h
index f77ea35..5f427be 100644
--- a/src/StreamBusInterface.h
+++ b/src/StreamBusInterface.h
@@ -59,6 +59,7 @@ public:
         virtual long priority();
         virtual const char* getInTerminator(size_t& length) = 0;
         virtual const char* getOutTerminator(size_t& length) = 0;
+        virtual unsigned long getPeekSize() = 0;
     public:
         virtual const char* name() = 0;
         virtual ~Client();
@@ -136,6 +137,8 @@ protected:
         { return client->getInTerminator(length); }
     const char* getOutTerminator(size_t& length)
         { return client->getOutTerminator(length); }
+    unsigned long getPeekSize()
+        { return client->getPeekSize(); }
     long priority() { return client->priority(); }
     const char* clientName() { return client->name(); }
 
diff --git a/src/StreamCore.cc b/src/StreamCore.cc
index 1943bf1..28bbbcd 100644
--- a/src/StreamCore.cc
+++ b/src/StreamCore.cc
@@ -99,6 +99,7 @@ printProtocol()
     printf("  writeTimeout  = %ld; # ms\n", writeTimeout);
     printf("  pollPeriod    = %ld; # ms\n", pollPeriod);
     printf("  maxInput      = %ld; # bytes\n", maxInput);
+    printf("  peekSize      = %ld; # bytes\n", peekSize);
     StreamProtocolParser::printString(buffer.clear(), inTerminator());
     printf("  inTerminator  = \"%s\";\n", buffer());
         StreamProtocolParser::printString(buffer.clear(), outTerminator());
@@ -240,6 +241,7 @@ compile(StreamProtocolParser::Protocol* protocol)
     replyTimeout = 1000;
     writeTimeout = 100;
     maxInput = 0;
+    peekSize = 1;
     pollPeriod = 1000;
     inTerminatorDefined = false;
     outTerminatorDefined = false;
@@ -256,6 +258,7 @@ compile(StreamProtocolParser::Protocol* protocol)
         protocol->getNumberVariable("replytimeout", replyTimeout) &&
         protocol->getNumberVariable("writetimeout", writeTimeout) &&
         protocol->getNumberVariable("maxinput", maxInput) &&
+        protocol->getNumberVariable("peeksize", peekSize) &&
         // use replyTimeout as default for pollPeriod
         protocol->getNumberVariable("replytimeout", pollPeriod) &&
         protocol->getNumberVariable("pollperiod", pollPeriod)))
diff --git a/src/StreamCore.h b/src/StreamCore.h
index 560af49..4ef5100 100644
--- a/src/StreamCore.h
+++ b/src/StreamCore.h
@@ -147,6 +147,7 @@ protected:
     unsigned long readTimeout;
     unsigned long pollPeriod;
     unsigned long maxInput;
+    unsigned long peekSize;
     bool inTerminatorDefined;
     bool outTerminatorDefined;
     StreamBuffer inTerminator;
@@ -202,6 +203,10 @@ protected:
     void disconnectCallback(StreamIoStatus status);
     const char* getInTerminator(size_t& length);
     const char* getOutTerminator(size_t& length);
+    unsigned long getPeekSize()
+	{
+		return peekSize;
+	}
 
 // virtual methods
     virtual void protocolStartHook() {}
diff --git a/src/StreamEpics.cc b/src/StreamEpics.cc
index 9117fd9..3eab322 100644
--- a/src/StreamEpics.cc
+++ b/src/StreamEpics.cc
@@ -843,6 +843,7 @@ protocolFinishHook(ProtocolResult result)
                     // but now this record has a value
                     record->sevr = NO_ALARM;
                     record->stat = NO_ALARM;
+                    recGblGetTimeStamp(record);
                 }
             }
             break;
